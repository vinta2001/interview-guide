### 死锁的条件是什么？如何避免死锁？
- 互斥：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。
- 请求并持有：一个线程已经持有一个资源，并且在等待获取其他线程持有的资源。
- 不可剥夺：资源不能被强制从线程中夺走，必须等线程自己释放。
- 环路等待：存在一种线程等待链，线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，直到线程 N 又等待线程 A 持有的资源。

运行 `jstack pid` 命令，可以看到死锁的线程信息。

### synchronied锁升级了解吗？
synchronied从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁。没有线程竞争时，就使用低开销的“偏向锁”，此时没有额外的 CAS 操作；轻度竞争时，使用“轻量级锁”，采用 CAS 自旋，避免线程阻塞；只有在重度竞争时，才使用“重量级锁”，由 Monitor 机制实现，需要线程阻塞。

![alt text](./images/Mark%20Word.png)

- 一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。
- **当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态**。偏向锁会在Markword的偏向线程ID里存储当前线程的操作系统线程ID，偏向锁标识位是1，锁标识位是01。此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。
- **当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁**。此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试，当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。
- **当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁**。此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter指令插入到同步代码块在编译后的开始位置，monitorexit指令插入到同步代码块的结束处和异常处，这两个指令配对出现。

### ReentrantLock 的实现原理？
ReentrantLock是基于AQS实现的一个可重入排他锁（互斥锁）。在调用`lock()`方法时先尝试CAS设置state值，成功为持有锁。如果设置失败则尝试CAS获取锁，如果成功则持有锁。如果没有成功则加入到AQS队列中。