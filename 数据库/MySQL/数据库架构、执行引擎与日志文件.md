### 一条查询SQL请求的执行过程是什么？

- 客户端向MySQL服务器发送SQL查询语句
- **连接器**处理这个请求：与客户端**建立连接、获取权限、管理连接**.
- **服务层**根据SQL语句查询缓存，如果缓存命中则直接返回（MySQL 8.0 已经删除）。
- **解析器**对SQL语句进行解析：对SQL进行词法分析（拆SQL，识别关键字和表名、列名）、语法分析（检查语法规范，并构建抽象语法树）。
- **优化器**确定SQL语句的执行计划，包括语义分析（检查表和列是否存在），选择使用哪些索引，以及决定表之间的连接顺序等。
- **执行器**调用存储引擎的API来读取数据。
- **引擎层**执行SQL语句获取数据并返回给服务层。如果是InnoDB引擎，先在缓冲池中获取数据，如果没有则在硬盘中加载数据页到缓冲池，然后返回符合条件的记录给服务层。
- **服务层**将结果返回给客户端。

### 一条更新SQL请求的执行过程是什么？

总的来说，一条 UPDATE 语句的执行过程包括读取数据页、加锁解锁、事务提交、日志记录等多个步骤。

- 服务层执行器开启事务并从引擎层获取数据。引擎层首先从内存中获取数据，如果内存中没有则从硬盘加载**数据页**
  到内存中。然后返回符合条件的行记录（数据）到服务层。引擎层在**读取数据时**会加锁。
- 服务层计算新值后调用引擎层更新接口，引擎层在Buffer Pool中更新行记录（数据），然后记录undolog并将数据页标记为脏页，记录
  redolog（以缓存的形式存在）并标记为 prepare 状态并通知服务层。
- 服务层将更新记录写入到 binlog 中，然后通知引擎层。
- 引擎层将redolog标记为`commit`状态。刷盘之前，redolog以缓存的形式存在。
- 服务层将事务状态更新为已提交。引擎层清理事务相关资源、释放锁。
- 后台线程根据`innodb_flush_log_at_trx_commit`配置将redolog刷盘然后将脏页刷盘。根据WAL（日志先行）原则，日志比数据先一步刷入磁盘，这样能保证事务安全。
  ![update执行过程](./images/update执行顺序.png)
  所以在更新过程中，服务层的作用是开启和关闭事务，获取并更新数据、记录binlog。而引擎层则需要管理事务相关的资源，更新数据，记录脏页、undolog和redolog。

### MySQL中的缓存

MySQL中的缓存是指MySQL的内存中的缓存，包括内存表缓存、内存索引缓存和内存查询缓存等。这些缓存可以加快MySQL的查询性能，但也会占用内存资源。

| 缓存类型         | 层级  | 作用                                 | 配置参数                               |
|--------------|-----|------------------------------------|------------------------------------|
| 查询缓存         | 服务层 | 缓存SQL执行结果集                         | `query_cache_size`（MySQL 5.7-版本存在） |
| 表缓存          | 服务层 | 存储表结构数据                            | 无                                  |
| 排序缓存         | 服务层 | 优化排序操作                             | `sort_buffer_size`                 |
| 键缓存(MyISAM)  | 引擎层 | 缓存 MyISAM 表的索引数据，加速索引查找            | `key_buffer_size`                  |
| 缓冲池(InnoDB)  | 引擎层 | 缓存数据页和索引页，实现 “预读” 和 “写缓冲”，大幅减少磁盘访问 | `innodb_buffer_pool_size`          |
| 日志缓冲(InnoDB) | 引擎层 | 缓存 InnoDB 的 redo 日志，减少日志写入磁盘的频率    | `innodb_log_buffer_size`           |

### 谈一下对InnoDB的Buffer pool的了解
![Buffer-pool](./images/Buffer-pool.png)
Buffer pool是InnoDB引擎的一个内存缓冲区，它会将查询到的数据页和索引页加载到内存中，读的时候先读取Buffer pool中的数据，如果命中就不用访问硬盘。

如果没有命中，就从磁盘读取，并加载到 Buffer Pool，此时可能会触发页淘汰，将不常用的页移出 Buffer Pool。

写操作时不会直接写入磁盘，而是先修改内存中的页，此时页被标记为脏页，后台线程会定期将脏页刷新到磁盘。Buffer Pool 可以显著减少磁盘的读写次数，从而提升 MySQL 的读写性能。

![Buffer-pool-LRU](./images/Buffer-pool-LRU.png)
InnoDB对LRU进行了改良，最近访问的数据不会放到LUR链表头部，而是放到midpoint的位置。一般情况下midpoint在LRU链表的5/8处。只有当数据被频繁访问时才会移动到young区。这样做的好处是热点页能长时间保留在内存中，不容易被挤出去。
![InnoDB优化的LRU](./images/InnoDB优化的LRU.png)
默认情况下，LRU 链表中 old 区占 37%；同一页再次访问提升的最小时间间隔是 1000 毫秒。
也就是说，如果某页在 1 秒内被多次访问，只会计算一次，不会立刻升级为热点页，防止短时间批量访问导致缓存污染。

### MySQL的引擎有哪些？有了解过吗？

- InnoDB: InnoDB是MySQL**默认引擎**，支持**ACID事务**、**行级锁**、**外键约束**
  等功能。InnoDB引擎具有很好的高并发读写性能，支持较好的数据完整性和并发控制，适用于高并发的读写操作。InnoDB还利用redolog实现了崩溃恢复的功能。
- MyISAM: MyISAM是MySQL另一种常见的引擎，具有**较低的存储空间和内存消耗**
  ，适用于大量的读操作。但是由于MyISAM不支持事务、行级锁、外键约束，在数据完整性的支持和并发写操作性能方面有一定限制。
- Memory: Memory把数据存储在内存中，适用于对性能要求较高的读操作场景。但是如果服务器宕机或关机则会导致数据丢失。另外，MyISAM也不支持事务、行级锁和外键约束。

### 为什么InnoDB是MySQL的默认引擎？

- 事务支持：InnoDB提供了事务支持，可以实现事务的ACID（原子性、一致性、隔离性、持久性）操作。其他引擎是不支持事务的。
- 并发性能：InnoDB实现了行级锁，可以提供更好的并发性能。MyISAM只支持表级锁，锁粒度太大。
- 崩溃恢复：InnoDB通过redolog日志实现了崩溃恢复，可以在数据库发生异常情况时，通过日志文件进行数据恢复，保证了数据的持久性和一致性。其他引擎是不支持的。

### InnoDB和MyISAM引擎有什么区别？

| 引擎     | 事务    | 索引                           | 外键    | 崩溃恢复能力          |
|--------|-------|------------------------------|-------|-----------------|
| InnoDB | 支持事务  | 支持全文索引、B+树索引、哈希索引 索引结构为聚簇索引 | 支持外键  | 通过redolog支持崩溃恢复 |
| MyISAM | 不支持事务 | 支持全文索引、B+树索引                 | 不支持外键 | 没有崩溃恢复能力        |
| MEMORY | 不支持事务 | 支持B+树索引和哈希索引                 | 不支持外键 | 没有崩溃恢复能力        |