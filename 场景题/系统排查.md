### 如何在服务器上查看错误日志？
- `cat 日志文件`：查看完整日志
- `tail -f 日志文件`：实时追踪日志更新（常用！）
- `grep "关键词" 日志文件`：搜索包含特定关键词（如error）的日志
- `less 日志文件`：分页查看大日志（按q退出，/搜索）
- `tail -n 100 日志文件`：查看最后 100 行日志
- `awk '$2=="ERROR" && $3=="trace-123456" {print $0}' app.log`

### awk指令怎么使用？
参考链接：[awk指令的使用](https://www.runoob.com/linux/linux-comm-awk.html)
```bash
awk options 'pattern {action}' file
```
选项参数说明：
- options：是一些选项，用于控制 awk 的行为。
- pattern：是用于匹配输入数据的模式。如果省略，则 awk 将对所有行进行操作。
- {action}：是在匹配到模式的行上执行的动作。如果省略，则默认动作是打印整行。

### 如何检查服务器的CPU负载过高的问题？
- 定位高CPU占用进程：`top`命令找到对应的进程ID 
- 根据进程ID找到导致CPU飙高的线程：`top -Hp <PID>`
- 将线程ID转化为16进制：`printf "%x\n" <TID>`
- 获取线程堆栈信息：`jstack <PID> | grep -A 10 <TID>` （其实就是找到进程-线程堆栈信息，打印对应的前10行信息）
- 根因分析（分析堆栈信息）（比如死循环、大量线程上下文切换、死锁、大量FullGC）

### 如何排查java频繁GC的问题？

- 第一步：确认 GC 类型与频率（区分 Young/Old GC）

```bash
# 格式：jstat -gcutil [进程ID] [采样间隔(ms)] [采样次数]
jstat -gcutil 12345 1000 10  # 对PID=12345的进程，每1秒采样1次，共10次
jstat -gcnew 12345 1000  # 查看Young区GC的详细统计
```

- 第二步：捕获 “高对象创建” 时刻的线程栈（**创建线程快照**），查看线程运行状态，通过jstack来查看各个线程调用堆栈，就知道线程在后台做了什么，或者等待什么资源。

```bash
# 连续生成2-3次线程快照（间隔几秒），捕捉高频活动的线程
jstack 12345 > thread_dump1.txt
sleep 3
jstack 12345 > thread_dump2.txt
jstack 12345 | grep -i runnable #先快速定位活跃线程
```

- 。第三步：关联线程与内存对象（找到 “线程创建的对象类型”），生成**堆快照**后，需要使用 MAT、VisualVM 等工具分析

```bash
# 查看当前存活对象的类统计（按实例数/大小排序），-live 表示只统计存活对象
jmap -histo:live 12345 | head -20  # 取前20行，聚焦数量/大小top的类
# 生成堆内存快照（.hprof文件），-live 只dump存活对象（减小文件体积）
jmap -dump:live,format=b,file=heap_dump.hprof 12345
```

- 第四步：验证 JVM 参数是否合理 —— 用 `jinfo` 查看 Young 区配置

```bash
# 查看JVM所有非默认参数，过滤Young区相关配置
jinfo -flags 12345 | grep -E "NewSize|MaxNewSize|SurvivorRatio|MetaspaceSize"
```

- 第五步：修改JVM参数

```bash
-Xmn2g（若总堆4g）#增大年轻代
-XX:SurvivorRatio=6 #调整Survivor比例
-XX:MaxTenuringThreshold=15 #控制晋升年龄
-XX:+UseG1GC -XX:MaxGCPauseMillis=200 #使用G1回收器减少停顿
```

